Important, low-level stuff:
Should row adding and removing be done at the end of the array, or at the cursor's current position?

Nice features:
It's probably time I stopped thinking of each channel as consisting of a pitch, a gate of a specified duration, CV1 and CV2.  Instead, it would now probably be wiser to think of each channel as either a CV or a gate.  All CVs can be treated as pitches or not.  It makes no difference.  They're all set with a value between 0 and 60, representing 0V to +5V in 0.08(3) increments, and they can all respond to slide.  Some of these should be joined together, so that whenever the pitch is sliding, the corresponding gate should be too in order to ensure it will stay open the whole note duration, but I should thinking about whether such grouping should be implemented by the interface / application, not the library.  So one channel / note in the application might behind-the-scenes control multiple channels in the library.  If I proceed this way, each event would simply consist of an optional value in the range of 0 to 60, and a boolean for whether it's sliding or not.
I need to improve the README file.
I should finish implementing the methods necessary to in turn build a realtime interface, eg moving a virtual cursor around, getting and setting the values at that cursor's current event position and so on.
I should implement multiple patterns, switching between them, chaining them together, copying them and removing them.
I should work out a song file format, that stores (preferably in XML to make life easier for other people) the song name, artist name, arbitrary information, all events for every channel of each pattern, and the ordering of all the patterns.  I should then get the sequencer to read and write these files.  (The idea being that the hardware implementation could write them to SD cards.)
Make an ADSR envelope generator; use the attenuator with that instead.
Make a voltage controlled slew limiter module.  (Basically like the sequencer's slide and the delay module.)
Make a sample and hold module.
Make a voltage controlled delay / echo module.  (With a set sized array, cycled through at a voltage controlled speed, with a voltage controlled amount of feedback and a voltage controlled dry/wet mix.)
Have a go at making a chorus.  (I gather this is something like an extremely short delay with only one copy of the signal and a slightly variable speed.)

Distant dreams:
A multimode filter would be nice, but is probably beyond my abilities.
A realtime user interface version of the sequencer, that lets you edit rather than passively play notation, with load and save facilities and audio output (even if just sine waves and white noise) would be great, and pave the way for a hardware version of it.
A port of this written in C or C++ would be great.  It would not only be faster, but could be integrated with hardware via an Arduino board.
I need to think about whether the software modules should be part of the file format (so songs can include information about which modules are used, and how they're hooked up to the sequencer and each other), or not.  They might work as an extension to the main file format, but the main focus should be on the sequencer, and allowing it to be used with real world synthesisers, not tying it down to a software-only implementation.
Allow the user to change the tempo with each event row.  It works best as a 3-digit int, not as a bipolar control voltage, so it would make more sense to set it within the pattern, in a new kind of non-channel-specific column, than via CV in.
