Important, low-level stuff:
I should really consider properly splitting up semitones and octaves internally, and using a numbering scheme to store them as integers, with 0 being C, 6 being F# etc.
Should the sequencer have the arrays self.patternsInCentsAndDots and self.patternsInCents, each with cv1 etc, or should it have the single array self.patterns with cv1InCents and cv1InCentsAndDots etc?  I think the former, so that it can be easily ported to C, in which all of an array's elements must be of the same type.
I think I've been going about this the wrong way... whenever you *write* something, the pattern should be updated, and the pattern array should include not just the InCentsAndDots/InCharsAndDots data, but also the InCents and InChars versions too.  Whenever you *read* something, it should read in the non-dotted versions only, and convert those into their InUnipolarVolts equivalents to output.  The only reason they shouldn't also be included in the pattern array is because of slides and gates, therefore how the exact time (as we may not necessarily be at the beginning of a row) can affect those values.
In Stepper 3, the gate "LED" may be faulty.  The accent one definitely is.  The overall issue is that I decided CVs should be remembered from one event to the next by default (the default being an entry of '..').  Maybe by default they should revert to 00?  I'll need to think about this.  Should I even get rid of '..' defaults altogether and have everything set to a C-2 rest with everything off until overridden?
Once loadSong() is implemented, Entirely remove addEventRow() (or at least the data loading part of it).
Stepper 3 should default to a CV1 of '00' (off), not '..' (continue what it was in the last step), because for this one particular interface to Surf, CV1 is being used for the note's accent.

Nice features:
I need to improve the README file.
I should finish implementing the methods necessary to in turn build a realtime interface, eg moving a virtual cursor around, getting and setting the values at that cursor's current event position and so on.
I should implement multiple patterns, switching between them, chaining them together, copying them and removing them.
I should work out a song file format, that stores (preferably in XML to make life easier for other people) the song name, artist name, arbitrary information, all events for every channel of each pattern, and the ordering of all the patterns.  I should then get the sequencer to read and write these files.  (The idea being that the hardware implementation could write them to SD cards.)
I'm tempted to make the arbitrary CV values count from 00 to 50 instead of 00 to 99.  That way, making exact half (if not quarter) values is possible (although a range of 00 to 80 would accomplish that better), plus converting into volts is simply a matter of dividing by ten, or picturing a decimal point being there.  000 to 500 (or even 0000 to 5000) would be even better, as it would probably be precise enough to allow CV1 and CV2, if required, to output notes, at a pinch, as a hack.  It wouldn't be intuitive, but it would enable a triad chord to be played on each channel.  And, of course, minimum and maximum values lets you use CV1 and CV2 as event-row-length gates.
Make an ADSR envelope generator; use the attenuator with that instead.
Make a voltage controlled slew limiter module.  (Basically like the sequencer's slide and the delay module.)
Make a sample and hold module.
Make a voltage controlled delay / echo module.  (With a set sized array, cycled through at a voltage controlled speed, with a voltage controlled amount of feedback and a voltage controlled dry/wet mix.)
Have a go at making a chorus.  (I gather this is something like an extremely short delay with only one copy of the signal and a slightly variable speed.)

Distant dreams:
A multimode filter would be nice, but is probably beyond my abilities.
A realtime user interface version of the sequencer, that lets you edit rather than passively play notation, with load and save facilities and audio output (even if just sine waves and white noise) would be great, and pave the way for a hardware version of it.
A port of this written in C would be great.  It would not only be faster, but could be integrated with hardware via an Arduino board.
I need to think about whether the software modules should be part of the file format (so songs can include information about which modules are used, and how they're hooked up to the sequencer and each other), or not.  They might work as an extension to the main file format, but the main focus should be on the sequencer, and allowing it to be used with real world synthesisers, not tying it down to a software-only implementation.
Allow the user to change the tempo with each event row.  It works best as a 3-digit int, not as a bipolar control voltage, so it would make more sense to set it within the pattern, in a new kind of non-channel-specific column, than via CV in.
